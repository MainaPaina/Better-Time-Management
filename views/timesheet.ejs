<div class="container">
    <div class="page-header">
        <h1 class="page-title">My Timesheet</h1>
        <p class="page-subtitle">Track your work hours and productivity</p>
    </div>

    <!-- Dashboard Cards -->
    <div class="dashboard-cards">
        <div class="dashboard-card">
            <div class="card-icon">
                <i class="fas fa-sign-in-alt"></i>
            </div>
            <div class="card-content">
                <h4>Today's Login</h4>
                <p class="card-value"><%= clockInTime ? clockInTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'N/A' %></p>
            </div>
        </div>

        <div class="dashboard-card">
            <div class="card-icon">
                <i class="fas fa-clock"></i>
            </div>
            <div class="card-content">
                <h4>Hours Today <i class="fas fa-info-circle" title="Shows hours worked today and remaining time in your 8-hour shift"></i></h4>
                <div class="countdown-container">
                    <div class="hours-display">
                        <div class="hours-row">
                            <span class="hours-label">Worked:</span>
                            <span id="hours-worked" class="hours-value">
                                --h --m
                            </span>
                        </div>
                        <div class="hours-row">
                            <span class="hours-label">Remaining:</span>
                            <span id="hours-remaining" class="hours-value">
                                --h --m
                            </span>
                        </div>
                        <!-- Progress Bar (relies on data attributes and JS) -->
                        <div class="progress-bar-container">
                            <div id="work-progress-bar" class="progress-bar" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard-card">
            <div class="card-icon">
                <i class="fas fa-calendar"></i>
            </div>
            <div class="card-content">
                <h4>This Week</h4>
                <p class="card-value">32.5 hrs / 40 hrs</p>
            </div>
        </div>
    </div>

    <!-- Time Tracking Panel -->
    <div class="time-tracking-panel card">
        <div class="panel-header">
            <h3>Time Tracking</h3>
            <div class="status-indicator <%= activeEntry ? 'active' : 'inactive' %>">
                <span class="status-dot"></span>
                <span class="status-text"><%= activeEntry ? 'Working' : 'Not Working' %></span>
            </div>
        </div>
        <div class="panel-body">
            <p>Your current status: <span id="statusText">Loading...</span></p>
            <p>Clocked in at: <span id="clockInTime">--:--</span></p>
            <p>Total Break Time: <span id="totalBreakTime">0 mins</span></p>
            <div class="tracking-actions">
                <button id="clockInBtn" class="btn btn-primary tracking-btn btn-start">Clock In</button>
                <button id="clockOutBtn" class="btn btn-secondary tracking-btn btn-stop" disabled>Clock Out</button>
                <button id="startBreakBtn" class="btn btn-secondary tracking-btn btn-pause" disabled>Start Break</button>
                <button id="endBreakBtn" class="btn btn-primary tracking-btn btn-resume" disabled>End Break</button>
                <button id="startUnavailableBtn" class="btn btn-secondary tracking-btn btn-unavailable" disabled>Go Unavailable</button>
                <button id="endUnavailableBtn" class="btn btn-primary tracking-btn btn-resume" disabled>Go Available</button>
            </div>
        </div>
    </div>

    <!-- Timesheet Controls -->
    <div class="timesheet-controls">
        <div class="control-panel card">
            <div class="panel-header">
                <h3>View Timesheet</h3>
            </div>
            <div class="panel-body">
                <div class="period-selector">
                    <label class="selector-label">Select Period</label>
                    <div class="period-options">
                        <div class="period-option btn btn-secondary active" data-period="current-week">Current Week</div>
                        <div class="period-option btn btn-secondary" data-period="last-week">Last Week</div>
                        <div class="period-option btn btn-secondary" data-period="current-month">Current Month</div>
                        <div class="period-option btn btn-secondary" data-period="custom">Custom</div>
                    </div>

                    <div class="custom-dates" style="display: none;">
                        <div class="date-input">
                            <label class="date-label">Start Date</label>
                            <input type="date" class="date-field" id="start-date">
                        </div>
                        <div class="date-input">
                            <label class="date-label">End Date</label>
                            <input type="date" class="date-field" id="end-date">
                        </div>
                    </div>
                </div>

                <div class="filter-section">
                    <h4 class="filter-title">Filter By</h4>
                    <div class="filter-options">
                        <div class="filter-chip btn btn-secondary"><i class="fas fa-check-circle"></i> Approved</div>
                        <div class="filter-chip btn btn-secondary"><i class="fas fa-clock"></i> Pending</div>
                        <div class="filter-chip btn btn-secondary"><i class="fas fa-times-circle"></i> Rejected</div>
                    </div>
                </div>

                <button class="btn btn-primary apply-button"><i class="fas fa-filter"></i> Apply Filters</button>
            </div>
        </div>

        <!-- Today's Clock-in Entries -->
        <div class="card timesheet-table-container" id="clock-in-entries">
            <div class="table-header">
                <h3>Today's Clock-in Entries</h3>
                <div class="table-actions">
                    <button class="btn btn-secondary table-action-btn"><i class="fas fa-sync"></i> Refresh</button>
                </div>
            </div>

            <div class="table-responsive">
                <!-- Debug info to check if today's entries exist -->
                <div style="margin-bottom: 10px; color: #666; font-size: 0.9rem;">
                    <% if (entries && entries.length > 0) { %>
                        Found <%= entries.length %> entries for today.
                    <% } else { %>
                        No entries found for today.
                    <% } %>
                </div>

                <table class="timesheet-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Clock In</th>
                            <th>Clock Out</th>
                            <th>Break Time</th>
                            <th>Unavailable Time</th>
                            <th>Hours</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <%
                        // Debug logging to see what today's entries are available
                        console.log('Today\'s entries in view:', entries);

                        if (entries && entries.length > 0) {
                        %>
                            <% entries.forEach((entry, index) => {
                                // Format times
                                let clockInTime = 'N/A';
                                if (entry.start_time) {
                                    const startTime = new Date(entry.start_time);
                                    clockInTime = startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                }

                                let clockOutTime = 'N/A';
                                if (entry.end_time) {
                                    const endTime = new Date(entry.end_time);
                                    clockOutTime = endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                }

                                // Format hours
                                let hoursDisplay = 'N/A';
                                if (entry.hours_worked !== null && entry.hours_worked !== undefined) {
                                    const hours = Math.floor(entry.hours_worked);
                                    const minutes = Math.round((entry.hours_worked % 1) * 60);
                                    hoursDisplay = `${hours}h ${minutes}m`;
                                }
                            %>
                                <tr>
                                    <td><%= index + 1 %></td>
                                    <td><%= clockInTime %></td>
                                    <td><%= clockOutTime %></td>
                                    <td><%= entry.total_break_duration || 0 %> mins</td>
                                    <td><%= entry.total_unavailable_duration || 0 %> mins</td>
                                    <td><%= hoursDisplay %></td>
                                    <td>
                                        <%
                                          const status = (entry.rawEntry && entry.rawEntry.status) ? entry.rawEntry.status : 'Unknown';
                                          const statusClass = status.toLowerCase();
                                        %>
                                        <span class="status-badge status-<%= statusClass %>"><%= status %></span>
                                    </td>
                                </tr>
                            <% }); %>
                        <% } else { %>
                            <tr>
                                <td colspan="7" class="no-entries">No clock-in entries for today</td>
                            </tr>
                        <% } %>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Recent Time Entries -->
        <div class="card timesheet-table-container">
            <div class="table-header">
                <h3>Recent Time Entries</h3>
                <div class="table-actions">
                    <button class="btn btn-secondary table-action-btn"><i class="fas fa-download"></i> Export</button>
                    <button class="btn btn-secondary table-action-btn"><i class="fas fa-print"></i> Print</button>
                </div>
            </div>

            <div class="table-responsive">
                <!-- Debug info to check if entries exist -->
                <div style="margin-bottom: 10px; color: #666; font-size: 0.9rem;">
                    <% if (entries && entries.length > 0) { %> <%# Use entries directly %>
                        Found <%= entries.length %> recent entries. <%# Use entries directly %>
                    <% } else { %>
                        No recent entries found.
                    <% } %>
                </div>

                <table class="timesheet-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Clock In</th>
                            <th>Clock Out</th>
                            <th>Break Time</th>
                            <th>Unavailable Time</th>
                            <th>Total Hours</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <%
                        // Debug logging to see what entries are available
                        console.log('Entries in view:', entries);

                        if (entries && entries.length > 0) {
                        %>
                            <% entries.forEach((entry, index) => { %>
                                <%
                                // Debug logging for each entry
                                console.log(`Rendering entry ${index}:`, entry);
                                %>
                                <tr>
                                    <td><%= entry.date || 'N/A' %></td>
                                    <td><%= entry.login || 'N/A' %></td>
                                    <td><%= entry.logout || 'N/A' %></td>
                                    <td><%= entry.pause || '0 mins' %></td>
                                    <td><%= entry.unavailable || '0 mins' %></td>
                                    <td><%= entry.totalAvailable || 'N/A' %></td>
                                    <td>
                                        <% 
                                          // Access status via rawEntry, with safety checks
                                          const status = (entry.rawEntry && entry.rawEntry.status) ? entry.rawEntry.status : 'Unknown';
                                          const statusClass = status.toLowerCase();
                                        %>
                                        <span class="status-badge status-<%= statusClass %>"><%= status %></span>
                                    </td>
                                </tr>
                            <% }); %>
                        <% } else { %>
                            <tr>
                                <td colspan="7" style="text-align: center; padding: 20px; color: #777; font-style: italic;">No recent time entries found.</td>
                            </tr>
                        <% } %>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Statistics Section -->
    <div class="stats-section">
        <h3 class="section-title">Work Statistics <span class="title-highlight"></span></h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-icon">
                    <i class="fas fa-chart-line"></i>
                </div>
                <div class="stat-content">
                    <h4>Productivity</h4>
                    <div class="stat-value">85%</div>
                    <div class="progress-bar">
                        <div class="progress" style="width: 85%"></div>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon">
                    <i class="fas fa-history"></i>
                </div>
                <div class="stat-content">
                    <h4>Average Hours</h4>
                    <div class="stat-value">7.5 hrs</div>
                    <div class="progress-bar">
                        <div class="progress" style="width: 75%"></div>
                    </div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon">
                    <i class="fas fa-user-clock"></i>
                </div>
                <div class="stat-content">
                    <h4>On Time Rate</h4>
                    <div class="stat-value">92%</div>
                    <div class="progress-bar">
                        <div class="progress" style="width: 92%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Custom Animations CSS -->
<style>
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .dashboard-card:hover .card-icon {
        animation: pulse 1.5s ease infinite;
    }

    @keyframes fadeSlideUp {
        0% {
            opacity: 0;
            transform: translateY(20px);
        }
        100% {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .animated {
        animation: fadeSlideUp 0.6s ease-out forwards;
    }

    section {
        opacity: 0;
        transform: translateY(40px);
        transition: opacity 0.8s ease, transform 0.8s ease;
    }

    section.visible {
        opacity: 1;
        transform: translateY(0);
    }

    /* Notification styles */
    .notification-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .notification {
        background-color: #333;
        color: white;
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-width: 300px;
        max-width: 400px;
        animation: slide-in 0.3s ease-out forwards;
    }

    .notification.success {
        background-color: #4CAF50;
    }

    .notification.error {
        background-color: #F44336;
    }

    .notification.warning {
        background-color: #FF9800;
    }

    .notification-content {
        flex: 1;
    }

    .notification-close {
        background: none;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        margin-left: 10px;
    }

    .notification.fade-out {
        animation: fade-out 0.3s ease-out forwards;
    }

    @keyframes slide-in {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    @keyframes fade-out {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }

    /* Highlight effect for buttons */
    .btn-highlight {
        animation: pulse 1s infinite;
        box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
    }

    @keyframes pulse {
        0% {
            transform: scale(1);
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }
        50% {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 165, 0, 1);
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
        }
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // Cache DOM elements
    const statusTextElement = document.getElementById('statusText');
    const clockInTimeText = document.getElementById('clockInTime');
    const totalBreakTimeText = document.getElementById('totalBreakTime');
    const clockInBtn = document.getElementById('clockInBtn');
    const clockOutBtn = document.getElementById('clockOutBtn');
    const startBreakBtn = document.getElementById('startBreakBtn');
    const endBreakBtn = document.getElementById('endBreakBtn');
    const startUnavailableBtn = document.getElementById('startUnavailableBtn');
    const endUnavailableBtn = document.getElementById('endUnavailableBtn');

    // Get elements needed for live updates
    const hoursWorkedElement = document.getElementById('hours-worked');
    const hoursRemainingElement = document.getElementById('hours-remaining');
    const progressBarElement = document.getElementById('work-progress-bar');

    // Helper to format hours into Xh Ym
    function formatHoursMinutes(decimalHours) {
        if (typeof decimalHours !== 'number' || isNaN(decimalHours)) {
            return 'N/A';
        }
        const totalMinutes = Math.max(0, Math.round(decimalHours * 60));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        return `${hours}h ${minutes}m`;
    }

    // Function to update the display live (will be called by setInterval)
    function updateLiveDisplay() {
        if (!window.sessionStartTime || window.baseHoursWorked === null) {
            // Not actively working or base data not set
            // console.log('Live update skipped: No session start time or base hours.');
            return;
        }

        const now = new Date();
        const elapsedMilliseconds = now - window.sessionStartTime;
        const elapsedSeconds = elapsedMilliseconds / 1000;
        const elapsedHours = elapsedSeconds / 3600;

        const currentTotalHours = window.baseHoursWorked + elapsedHours;
        const currentRemainingHours = Math.max(0, 8 - currentTotalHours); // Assuming 8-hour day

        // Update text content
        if (hoursWorkedElement) {
            hoursWorkedElement.textContent = formatHoursMinutes(currentTotalHours);
        }
        if (hoursRemainingElement) {
            hoursRemainingElement.textContent = formatHoursMinutes(currentRemainingHours);
        }

        // Update progress bar
        if (progressBarElement) {
            const percentage = Math.min(100, Math.max(0, (currentTotalHours / 8) * 100));
            progressBarElement.style.width = `${percentage}%`;
        }
    }

    // Function to display notifications
    function showNotification(message, type = 'info') {
        // Create notification container if it doesn't exist
        let notificationContainer = document.querySelector('.notification-container');

        if (!notificationContainer) {
            notificationContainer = document.createElement('div');
            notificationContainer.className = 'notification-container';
            document.body.appendChild(notificationContainer);
        }

        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <span>${message}</span>
            </div>
            <button class="notification-close">&times;</button>
        `;

        // Add notification to container
        notificationContainer.appendChild(notification);

        // Add close button functionality
        const closeButton = notification.querySelector('.notification-close');
        closeButton.addEventListener('click', function() {
            notification.classList.add('fade-out');
            setTimeout(() => {
                notification.remove();
            }, 300);
        });

        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.add('fade-out');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, 5000);
    }

    // Function to update the UI based on current timesheet status
    function updateUI(statusData) {
        const activeEntry = statusData.activeEntry;
        console.log('Updating UI with data:', statusData);

        // Clear previous timer interval if it exists
        if (window.liveTimerIntervalId) {
            clearInterval(window.liveTimerIntervalId);
            window.liveTimerIntervalId = null;
            console.log('Cleared existing live timer.');
        }
        // Reset base values used by the timer
        window.baseHoursWorked = null;
        window.sessionStartTime = null;

        const initialHoursWorked = statusData.hoursWorkedRaw !== undefined ? statusData.hoursWorkedRaw : 0;
        // Assume 8h day for remaining calculation if not provided
        const initialRemainingHours = statusData.remainingHoursRaw !== undefined ? statusData.remainingHoursRaw : Math.max(0, 8 - initialHoursWorked);

        // --- Update display elements initially based on statusData ---
        // Set static display elements based on fetched data. Live timer will overwrite if active.
        if (hoursWorkedElement) {
             hoursWorkedElement.textContent = formatHoursMinutes(initialHoursWorked);
        }
        if (hoursRemainingElement) {
            hoursRemainingElement.textContent = formatHoursMinutes(initialRemainingHours);
        }
         if (progressBarElement) {
             const initialPercentage = Math.min(100, Math.max(0, (initialHoursWorked / 8) * 100));
             progressBarElement.style.width = `${initialPercentage}%`;
         }

        // Reset all buttons to default state (mostly disabled)
        clockInBtn.disabled = true;
        clockOutBtn.disabled = true;
        startBreakBtn.disabled = true;
        endBreakBtn.disabled = true;
        startUnavailableBtn.disabled = true;
        endUnavailableBtn.disabled = true;
        statusTextElement.textContent = 'Not Clocked In';
        clockInTimeText.textContent = '--:--';
        totalBreakTimeText.textContent = '0 mins';

        if (activeEntry) {
            // User is clocked in
            clockOutBtn.disabled = false; // Base state when clocked in
            statusTextElement.textContent = `Status: ${activeEntry.status || 'Unknown'}`; // Default
            if (activeEntry.start_time) {
                clockInTimeText.textContent = new Date(activeEntry.start_time).toLocaleTimeString();
            }
             if (activeEntry.total_break_duration !== undefined) {
                 totalBreakTimeText.textContent = `${Math.round(activeEntry.total_break_duration)} mins`;
             }

            // Determine specific state based on status
            if (activeEntry.status === 'active') {
                startBreakBtn.disabled = false;
                startUnavailableBtn.disabled = false;
                clockOutBtn.disabled = false; // Ensure clock out is enabled
                statusTextElement.textContent = 'Active - Currently Working';

                // Store base hours and start time for the live timer
                // Use the initial values calculated above
                window.baseHoursWorked = initialHoursWorked;
                window.sessionStartTime = activeEntry.start_time ? new Date(activeEntry.start_time) : null;
                console.log('Base hours worked set:', window.baseHoursWorked);
                console.log('Session start time set:', window.sessionStartTime);

                // Start the live timer ONLY if sessionStartTime is valid and timer isn't already running
                if (window.sessionStartTime && !window.liveTimerIntervalId) {
                    console.log('Starting live timer.');
                    updateLiveDisplay(); // Initial update immediately using calculated live value
                    window.liveTimerIntervalId = setInterval(updateLiveDisplay, 1000);
                }
            } else {
                // Handle 'on_break', 'unavailable', or other clocked-in states
                // Timer should be stopped (already handled above by clearing interval)
                // Static display values (hours worked/remaining/progress) were already set
                // at the beginning of updateUI based on fetched data.
                if (activeEntry.status === 'on_break') {
                    endBreakBtn.disabled = false;
                    startBreakBtn.disabled = true;
                    startUnavailableBtn.disabled = true;
                    clockOutBtn.disabled = true;
                    statusTextElement.textContent = 'On Break';
                } else if (activeEntry.status === 'unavailable') {
                    endUnavailableBtn.disabled = false;
                    startBreakBtn.disabled = true;
                    startUnavailableBtn.disabled = true;
                    clockOutBtn.disabled = true;
                    statusTextElement.textContent = 'Unavailable';
                } else {
                     // Handle any other potential statuses or fallback
                     console.warn('Unknown activeEntry status:', activeEntry.status);
                     statusTextElement.textContent = `Status: ${activeEntry.status || 'Unknown'}`;
                     // Keep clock out enabled as a default if clocked in but status unknown?
                     clockOutBtn.disabled = false;
                }
                // Ensure clock-in is always disabled when clocked in
                clockInBtn.disabled = true;
            }
        } else {
            // User is not clocked in
            clockInBtn.disabled = false; // Enable clock-in
            statusTextElement.textContent = 'Not Clocked In';
             // Ensure progress bar resets if not clocked in
             if (progressBarElement) {
                 progressBarElement.style.width = '0%';
             }
             // Reset display hours explicitly to 0 / 8
             if (hoursWorkedElement) hoursWorkedElement.textContent = formatHoursMinutes(0);
             if (hoursRemainingElement) hoursRemainingElement.textContent = formatHoursMinutes(8);
        }
    }

    // Function to fetch status and update UI
    async function fetchAndUpdateStatus() {
        const token = localStorage.getItem('token'); // Get JWT from local storage
        console.log('Token available:', token ? 'Yes' : 'No');
        if (!token) {
            console.error('No JWT found. User might not be logged in.');
            statusTextElement.textContent = 'Error: Not authenticated';
            // Optionally redirect to login or disable all buttons
            return;
        }
        console.log('Using token for status fetch:', token.substring(0, 20) + '...');

        try {
            const response = await fetch('/api/status', { // Corrected endpoint
                 headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}` // Add JWT to header
                 }
            });
            if (!response.ok) {
                if (response.status === 401 || response.status === 403) {
                    // Handle unauthorized/forbidden (e.g., redirect to login)
                    console.error('Authentication error fetching status.');
                    statusTextElement.textContent = 'Authentication Error';
                    // Consider redirecting: window.location.href = '/login';
                } else {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return; // Stop further processing on error
            }
            const statusData = await response.json();
            updateUI(statusData);

            // Start the timer if the user is actively working and the timer is not already running
            if (statusData.activeEntry && statusData.activeEntry.status === 'active' &&
                typeof window.updateCountdown === 'function' && !window.timerRunning) {
                console.log('Starting timer from fetchAndUpdateStatus function');
                window.updateCountdown();
            }
        } catch (error) {
            console.error('Error fetching timesheet status:', error);
            statusTextElement.textContent = 'Error loading status';
            // Disable all buttons on error?
            clockInBtn.disabled = true;
            clockOutBtn.disabled = true;
            startBreakBtn.disabled = true;
            endBreakBtn.disabled = true;
            startUnavailableBtn.disabled = true;
            endUnavailableBtn.disabled = true;
        }
    }

    // Generic function to handle API calls for other timesheet actions
    async function handleTimesheetAction(action, successMessage, errorMessagePrefix) {
        console.log(`${action} button clicked`);
        const token = localStorage.getItem('token'); // Get JWT from local storage
        if (!token) {
            console.error('No JWT found for action.');
            showNotification('Authentication error. Please log in again.', 'error');
            return;
        }

        console.log(`Sending ${action} request to /api/${action}`);
        console.log('Using token:', token ? (token.substring(0, 20) + '...') : 'No token');

        try {
            const response = await fetch(`/api/${action}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}` // Add JWT to header
                },
            });

            console.log(`${action} response status:`, response.status);

            // Handle potential JSON parsing errors if response is not JSON (e.g., 204 No Content)
            let result = {};
            const contentType = response.headers.get("content-type");
            if (contentType && contentType.indexOf("application/json") !== -1) {
                try {
                    result = await response.json();
                    console.log(`${action} response data:`, result);
                } catch (jsonError) {
                    console.error(`Error parsing JSON response for ${action}:`, jsonError);
                    result = { error: 'Invalid response format' };
                }
            } else if (!response.ok) {
                 // If not JSON and not OK, create a basic error message
                 result = { error: `Request failed with status ${response.status}` };
                 console.error(`Non-JSON error response for ${action}:`, result.error);
            }

            if (response.ok) {
                console.log(`${action} successful:`, result);
                showNotification(successMessage, 'success');
                // Wait a moment before refreshing the UI to ensure the server has processed the change
                setTimeout(() => {
                    fetchAndUpdateStatus(); // Refresh UI
                }, 500);
            } else {
                const errorMessage = result.message || result.error || 'Unknown error';
                console.error(`${action} failed:`, errorMessage);
                showNotification(`${errorMessagePrefix}: ${errorMessage}`, 'error');
            }
        } catch (error) {
            console.error(`Error sending ${action} request:`, error);
            showNotification(`An error occurred while trying to ${action.replace('-', ' ')}.`, 'error');
        }
    }

    // Placeholder function to resolve ReferenceError
    async function checkAndFixTimesheetState() {
        console.warn('checkAndFixTimesheetState function is not fully implemented. Returning false.');
        // In a real implementation, this would:
        // 1. Fetch the current server state.
        // 2. Compare with local state/UI.
        // 3. If inconsistent, send a request to fix it on the server.
        // 4. Return true if a fix was attempted/successful, false otherwise.
        return false; // Indicate state was not fixed
    }

    // Check for inconsistent timesheet state on page load
    async function initialStateCheck() {
        try {
            // First check for inconsistent state
            const stateFixed = await checkAndFixTimesheetState();
            if (stateFixed) {
                console.log('Fixed inconsistent timesheet state on page load');
                // Wait a moment for the UI to update
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Then fetch and update status
            await fetchAndUpdateStatus();
        } catch (error) {
            console.error('Error during initial state check:', error);
            // Fall back to regular status fetch
            fetchAndUpdateStatus();
        }
    }

    // Initial status fetch on page load with state consistency check
    initialStateCheck();

    // Set up periodic refresh every 3 minutes to avoid conflicts with the timer
    const statusRefreshInterval = setInterval(() => {
        console.log('Performing periodic status refresh');
        // Only refresh if no timer is running
        if (!window.timerRunning) {
            console.log('No timer running, safe to refresh status');
            // Also check for inconsistent state during periodic refresh
            checkAndFixTimesheetState().then(stateFixed => {
                if (stateFixed) {
                    console.log('Fixed inconsistent timesheet state during periodic refresh');
                } else {
                    fetchAndUpdateStatus();
                }
            }).catch(error => {
                console.error('Error checking timesheet state during periodic refresh:', error);
                fetchAndUpdateStatus();
            });
        } else {
            console.log('Timer is running, skipping status refresh to avoid conflicts');
        }
    }, 180000); // 3 minutes

    // Clean up interval when page is unloaded
    window.addEventListener('beforeunload', () => {
        clearInterval(statusRefreshInterval);
    });

    // --- Event Listeners ---

    // Clock In
    if (clockInBtn) {
        clockInBtn.addEventListener('click', async () => {
            console.log('Clock In button clicked');
            try {
                const token = localStorage.getItem('token');
                console.log('Using token for clock-in:', token ? (token.substring(0, 20) + '...') : 'No token');

                if (!token) {
                    console.error('No JWT token found for clock-in');
                    showNotification('Authentication error. Please log in again.', 'error');
                    return;
                }

                // Default is not to force clock in
                let forceClockIn = false;

                console.log('Sending clock-in request to /api/clock-in');
                const response = await fetch('/api/clock-in', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}` // Add JWT to header
                    },
                    body: JSON.stringify({ force: forceClockIn })
                });

                console.log('Clock-in response status:', response.status);
                const result = await response.json();
                console.log('Clock-in response data:', result);

                // Check if we need to handle a stuck active entry
                if (response.status === 400 && result.canForceClockIn && result.activeEntry) {
                    console.log('Detected stuck active entry:', result.activeEntry);

                    // Calculate how long the entry has been active
                    const startTime = new Date(result.activeEntry.start_time);
                    const now = new Date();
                    const hoursActive = ((now - startTime) / (1000 * 60 * 60)).toFixed(1);

                    // Ask the user if they want to force clock in
                    const confirmForce = confirm(
                        `You appear to have an active timesheet entry from ${startTime.toLocaleString()} (${hoursActive} hours ago) ` +
                        `that was never properly closed.\n\n` +
                        `Would you like to automatically close this entry and clock in now?\n\n` +
                        `Note: This will calculate the hours worked for the previous entry and submit it.`
                    );

                    if (confirmForce) {
                        console.log('User confirmed force clock in');
                        // Send another request with force=true
                        const forceResponse = await fetch('/api/clock-in', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${token}`
                            },
                            body: JSON.stringify({ force: true })
                        });

                        console.log('Force clock-in response status:', forceResponse.status);
                        const forceResult = await forceResponse.json();
                        console.log('Force clock-in response data:', forceResult);

                        // Handle the force response directly instead of updating the original result
                        if (forceResponse.ok) {
                            // Show success message
                            const successMessage = forceResult.message || 'Successfully forced clock in.';
                            showNotification(successMessage, 'success');

                            // Process the entries if available
                            if (forceResult.allEntries && forceResult.allEntries.length > 0) {
                                console.log(`Received ${forceResult.allEntries.length} entries from force clock-in:`, forceResult.allEntries);

                                // Calculate total hours worked from all entries
                                let totalHoursWorked = 0;
                                forceResult.allEntries.forEach(entry => {
                                    if (entry.hours_worked !== null && entry.hours_worked !== undefined) {
                                        totalHoursWorked += parseFloat(entry.hours_worked);
                                    }
                                });

                                console.log('Total hours worked from force clock-in entries:', totalHoursWorked);
                                window.totalHoursWorkedToday = totalHoursWorked;
                            }

                            // Refresh the UI and return early
                            fetchAndUpdateStatus();
                            return;
                        } else {
                            // Show error message and return
                            showNotification(`Force clock in failed: ${forceResult.message || 'Unknown error'}`, 'error');
                            return;
                        }
                    } else {
                        console.log('User cancelled force clock in');
                        showNotification('Clock in cancelled. Please try again or contact support if the issue persists.', 'warning');
                        return;
                    }
                }

                if (response.ok) {
                    console.log('Clock in successful:', result);
                    // Use the message from the server if available, otherwise use a default message
                    const successMessage = result.message || 'Clocked in successfully!';
                    showNotification(successMessage, 'success');

                    // If the server returned all entries for today, log them
                    if (result.allEntries && result.allEntries.length > 0) {
                        console.log(`Received ${result.allEntries.length} entries for today:`, result.allEntries);

                        // Calculate total hours worked from all entries
                        let totalHoursWorked = 0;

                        // Sum up hours from completed entries
                        result.allEntries.forEach(entry => {
                            if (entry.hours_worked !== null && entry.hours_worked !== undefined) {
                                totalHoursWorked += parseFloat(entry.hours_worked);
                            }
                        });

                        console.log('Total hours worked from all entries:', totalHoursWorked);

                        // Store the total hours worked for the day in a global variable
                        // This ensures the timer doesn't reset when clocking in again on the same day
                        window.totalHoursWorkedToday = totalHoursWorked;
                        console.log('Stored total hours worked today:', window.totalHoursWorkedToday);

                        // Update the data attribute with the total hours worked
                        const hoursWorkedElement = document.getElementById('hours-worked');
                        const hoursWorkedData = document.getElementById('hours-worked-data');
                        const countdownElement = document.getElementById('countdown-timer');
                        const remainingHoursData = document.getElementById('remaining-hours-data');

                        // Calculate remaining hours
                        const remainingHours = Math.max(0, 8 - totalHoursWorked);

                        // Update all data attributes with the total hours worked and remaining hours
                        if (hoursWorkedElement) {
                            hoursWorkedElement.setAttribute('data-total-hours-worked', totalHoursWorked.toString());
                            hoursWorkedElement.setAttribute('data-server-hours-worked', totalHoursWorked.toString());
                        }

                        if (hoursWorkedData) {
                            hoursWorkedData.setAttribute('data-total-hours-worked', totalHoursWorked.toString());
                            hoursWorkedData.setAttribute('data-server-hours-worked', totalHoursWorked.toString());
                        }

                        if (countdownElement) {
                            countdownElement.setAttribute('data-server-remaining-hours', remainingHours.toString());
                        }

                        if (remainingHoursData) {
                            remainingHoursData.setAttribute('data-server-remaining-hours', remainingHours.toString());
                        }

                        console.log('Updated data attributes - Total hours worked:', totalHoursWorked, 'Remaining hours:', remainingHours);

                        // Refresh the today's entries table without a full page reload
                        const todayEntriesTable = document.querySelector('.timesheet-table tbody');
                        if (todayEntriesTable) {
                            // Clear existing entries
                            todayEntriesTable.innerHTML = '';

                            // Add new entries
                            result.allEntries.forEach((entry, index) => {
                                // Format times
                                let clockInTime = 'N/A';
                                if (entry.start_time) {
                                    const startTime = new Date(entry.start_time);
                                    clockInTime = startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                }

                                let clockOutTime = 'N/A';
                                if (entry.end_time) {
                                    const endTime = new Date(entry.end_time);
                                    clockOutTime = endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                }

                                // Format hours
                                let hoursDisplay = 'N/A';
                                if (entry.hours_worked !== null && entry.hours_worked !== undefined) {
                                    const hours = Math.floor(entry.hours_worked);
                                    const minutes = Math.round((entry.hours_worked % 1) * 60);
                                    hoursDisplay = `${hours}h ${minutes}m`;
                                }

                                // Create new row
                                const newRow = document.createElement('tr');
                                newRow.innerHTML = `
                                    <td>${index + 1}</td>
                                    <td>${clockInTime}</td>
                                    <td>${clockOutTime}</td>
                                    <td>${entry.total_break_duration || 0} mins</td>
                                    <td>${entry.total_unavailable_duration || 0} mins</td>
                                    <td>${hoursDisplay}</td>
                                    <td>
                                        ${(() => { // IIFE to calculate status and class
                                            const status = (entry.rawEntry && entry.rawEntry.status) ? entry.rawEntry.status : 'Unknown';
                                            const statusClass = status.toLowerCase();
                                            return `<span class="status-badge status-${statusClass}">${status}</span>`;
                                        })()}
                                    </td>
                                `;
                                todayEntriesTable.appendChild(newRow);
                            });
                        }
                    }

                    fetchAndUpdateStatus(); // Refresh UI
                } else {
                    const errorMessage = result.message || result.error || 'Unknown error';
                    console.error('Clock in failed:', errorMessage);
                    showNotification(`Clock in failed: ${errorMessage}`, 'error');
                }
            } catch (error) {
                console.error('Error sending clock in request:', error);
                showNotification('An error occurred while trying to clock in.', 'error');
            }
        });
    }

    // Clock Out with debounce to prevent multiple clicks
    if (clockOutBtn) {
        // Add a property to track if a request is in progress
        clockOutBtn.isProcessing = false;

        clockOutBtn.addEventListener('click', async () => {
            console.log('Clock Out button clicked');

            // Prevent multiple clicks
            if (clockOutBtn.isProcessing) {
                console.log('Clock out request already in progress, ignoring click');
                return;
            }

            // Disable the button immediately
            clockOutBtn.isProcessing = true;
            clockOutBtn.disabled = true;

            try {
                // First check if we're clocked in
                const currentStatus = statusTextElement.textContent.toLowerCase();
                if (currentStatus.includes('not clocked in')) {
                    console.log('Cannot clock out when not clocked in');
                    showNotification('You are not currently clocked in.', 'warning');
                    // Highlight the clock in button
                    if (clockInBtn) {
                        clockInBtn.classList.add('btn-highlight');
                        setTimeout(() => {
                            clockInBtn.classList.remove('btn-highlight');
                        }, 3000);
                    }
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                // Check if we're on break or unavailable
                if (currentStatus.includes('on break')) {
                    console.log('Cannot clock out while on break');
                    showNotification('Please end your break before clocking out.', 'warning');
                    // Highlight the end break button
                    if (endBreakBtn) {
                        endBreakBtn.classList.add('btn-highlight');
                        setTimeout(() => {
                            endBreakBtn.classList.remove('btn-highlight');
                        }, 3000);
                    }
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                if (currentStatus.includes('unavailable')) {
                    console.log('Cannot clock out while unavailable');
                    showNotification('Please end your unavailable period before clocking out.', 'warning');
                    // Highlight the end unavailable button
                    if (endUnavailableBtn) {
                        endUnavailableBtn.classList.add('btn-highlight');
                        setTimeout(() => {
                            endUnavailableBtn.classList.remove('btn-highlight');
                        }, 3000);
                    }
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                const token = localStorage.getItem('token');
                console.log('Using token for clock-out:', token ? (token.substring(0, 20) + '...') : 'No token');

                if (!token) {
                    console.error('No JWT token found for clock-out');
                    showNotification('Authentication error. Please log in again.', 'error');
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                // Ask for confirmation before clocking out
                if (!confirm('Are you sure you want to clock out?')) {
                    console.log('Clock out cancelled by user');
                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                    return;
                }

                console.log('Sending clock-out request to /api/clock-out');
                const response = await fetch('/api/clock-out', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}` // Add JWT to header
                    },
                });

                console.log('Clock-out response status:', response.status);
                const result = await response.json();
                console.log('Clock-out response data:', result);

                if (response.ok) {
                    console.log('Clock out successful:', result);
                    showNotification('Clocked out successfully!', 'success');

                    // Wait a moment before refreshing the UI to ensure the server has processed the change
                    setTimeout(() => {
                        fetchAndUpdateStatus(); // Refresh UI
                    }, 500);
                } else {
                    const errorMessage = result.message || result.error || 'Unknown error';
                    console.error('Clock out failed:', errorMessage);

                    // Handle specific error messages
                    if (errorMessage.includes('Not clocked in')) {
                        showNotification('You are not currently clocked in.', 'warning');
                    } else {
                        showNotification(`Clock out failed: ${errorMessage}`, 'error');
                    }

                    // Re-enable the button
                    clockOutBtn.isProcessing = false;
                    clockOutBtn.disabled = false;
                }
            } catch (error) {
                console.error('Error sending clock out request:', error);
                showNotification('An error occurred while trying to clock out.', 'error');

                // Re-enable the button
                clockOutBtn.isProcessing = false;
                clockOutBtn.disabled = false;
            }
        });
    }

    // Event listeners using the generic handler
    if (startBreakBtn) {
        startBreakBtn.addEventListener('click', () => {
            console.log('Start Break button clicked');
            // First check if we're already on break
            const currentStatus = statusTextElement.textContent.toLowerCase();
            if (currentStatus.includes('on break')) {
                console.log('Already on break');
                showNotification('You are already on break.', 'warning');
                return;
            }

            handleTimesheetAction('start-break', 'Break started successfully!', 'Failed to start break');
        });
    }

    if (endBreakBtn) {
        endBreakBtn.addEventListener('click', () => {
            console.log('End Break button clicked');
            // First check if we're actually on break
            const currentStatus = statusTextElement.textContent.toLowerCase();
            if (!currentStatus.includes('on break')) {
                console.log('Not on break');
                showNotification('You are not currently on break.', 'warning');
                return;
            }

            handleTimesheetAction('end-break', 'Break ended successfully!', 'Failed to end break');
        });
    }
    if (startUnavailableBtn) {
        startUnavailableBtn.addEventListener('click', () => handleTimesheetAction('start-unavailable', 'Marked as unavailable!', 'Failed to mark as unavailable'));
    }
    if (endUnavailableBtn) {
        endUnavailableBtn.addEventListener('click', () => handleTimesheetAction('end-unavailable', 'Marked as available!', 'Failed to mark as available'));
    }

});
</script>

<!-- Additional styles for tooltips and hours display -->
<style>
    /* Info icon tooltip */
    .fa-info-circle {
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.8rem;
        margin-left: 5px;
        cursor: help;
        transition: color 0.2s ease;
    }

    .fa-info-circle:hover {
        color: var(--accent-color);
    }

    /* Hours display styles */
    .hours-display {
        display: flex;
        flex-direction: column;
        gap: 5px;
        margin-bottom: 10px;
    }

    .hours-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .hours-label {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.8);
    }

    .hours-value {
        font-size: 1.2rem;
        font-weight: 600;
        color: white;
    }

    /* Status badge styles */
    .status-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
        font-weight: 500;
        text-transform: capitalize;
        background-color: #ccc;
        color: #333;
    }

    .status-badge.active {
        background-color: #4CAF50;
        color: white;
    }

    .status-badge.submitted {
        background-color: #2196F3;
        color: white;
    }

    .status-badge.on_break {
        background-color: #FF9800;
        color: white;
    }

    .status-badge.unavailable {
        background-color: #F44336;
        color: white;
    }

    .status-badge.completed {
        background-color: #9C27B0;
        color: white;
    }

    /* No entries message */
    .no-entries {
        text-align: center;
        padding: 20px;
        color: #777;
        font-style: italic;
    }

    /* Timesheet table styles */
    .timesheet-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
        background-color: var(--card-bg-color);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .timesheet-table th {
        background-color: var(--header-bg-color, #f5f5f5);
        color: var(--header-text-color, #333);
        padding: 12px 15px;
        text-align: left;
        font-weight: 600;
        border-bottom: 1px solid var(--border-color, #ddd);
    }

    .timesheet-table td {
        padding: 10px 15px;
        border-bottom: 1px solid var(--border-color, #eee);
        color: var(--text-color, #333);
    }

    .timesheet-table tr:last-child td {
        border-bottom: none;
    }

    .timesheet-table tr:hover {
        background-color: var(--row-hover-color, rgba(0, 0, 0, 0.02));
    }

    /* Dark mode adjustments */
    @media (prefers-color-scheme: dark) {
        .timesheet-table {
            background-color: var(--card-bg-color, #2a2a2a);
        }

        .timesheet-table th {
            background-color: var(--header-bg-color, #333);
            color: var(--header-text-color, #fff);
            border-bottom: 1px solid var(--border-color, #444);
        }

        .timesheet-table td {
            border-bottom: 1px solid var(--border-color, #333);
            color: var(--text-color, #eee);
        }

        .timesheet-table tr:hover {
            background-color: var(--row-hover-color, rgba(255, 255, 255, 0.05));
        }
    }
</style>
</body>
</html>
